\input texinfo          @c -*-texinfo-*-

@c %**start of header
@setfilename lsh.info
@settitle lsh
@c %**end of header

@ifinfo
Draft manual for LSH.

Copyright 2000 Niels Möller.

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@ignore
Permission is granted to process this file through TeX
and print the results, provided the printed document
carries a copying permission notice identical to this
one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end ifinfo

@titlepage
@sp 10
@center @titlefont{Draft LSH Manual}

@c  @title{Draft LSH Manual}
@c  @author{Niels Möller}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2000 Niels Möller.

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end titlepage

@node     Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up
@top

This document describes @code{lsh} and related programs. @code{lsh} suit
of programs is intended as a free replacement for the @code{ssh} suit of
programs. In turn, @code{ssh} was intended as a secure replacement for
the @code{rsh} and @code{rlogin} programs for remote login over the
internet.

@code{lsh} is a component of the @acronym{GNU} system.

This manual explains how to use and hack @code{lsh}.

@menu
* Introduction::                
* Installation::                
* Getting started::             
* Invoking lsh::                
* Invoking lshd::               
* Terminology::                 
* Concept Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Threats::                     
* Features::                    
* Related techniques::          

Related programs and techniques

* ssh1::                        SSH version 1
* ssh2::                        SSH version 2
* Kerberos::                    Kerberos
* ipsec::                       IP Sec

Invoking @code{lsh}

* Algorithms: Algorithm options.  Selecting algorithms.
* Hostauth options::            
* Userauth options::            
* Actions: Action options.      What to do after login.
* Messages: Verbosity options.  Tuning the amount of messages.

@end detailmenu
@end menu

@node Introduction, Installation, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

What is this thing called computer security anyway? Why would you want
to use a program like @code{lsh}?

This chapter explains the threats @code{lsh} tries to protect you from,
and some of the threats that remain. It also describes some of the
technologies used in @code{lsh}.

From time to time in this manual, I will speak about the @dfn{enemy}.
This means anybody who is trying to eavesdrop or disturb your private
communication. This usage is technical, and it does not imply that the
enemy is somehow morally inferior to you: The enemy may be some awful
criminals trying to eavesdrop on you, or it may be the police trying to
eavesdrop the same criminals.

The enemy can be a criminal, or a competitor, or your boss who's trying
to find out how much you tell collegues at competing firms. It may be
yours or somebody elses national security officials. Or your
ex-boyfriend who happens to be too curious.

So what can the enemy do to your communications and your privacy?
Remember that just because your paranoid that doesn't mean that nobody
is trying to get you@dots{}


@menu
* Threats::                     
* Features::                    
* Related techniques::          
@end menu

@node Threats, Features, Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section Threats

When logging in to some other machine via the internet, either in the
same building or e few continents away, there are several things that
may be under enemy attack.

@table @asis
@item @dfn{Local attacks}
The enemy controls your local environment. He or her may be looking over
your shoulder. Your local machine might be cracked. Or there may be some
device planted inside your keyboard transmitting everything you type to
the attacker. About the same problems occur if the attacker has taken
control over your target machine, i.e. the remote machine you have
logged in to.

@item @dfn{Denial of service}
The enemy has cut your network cable, effectively stopping your
communication. Even without doing physical damage, the enemy may be able
to flood and overload computers or network equipment. Or disrupt network
traffic by sending fake packets to hangup your @code{tcp/ip}
connections.

@item @dfn{Passive eavesdropping}
The enemy may be able to listen to your communication somewhere along
its path. With the global internet, it's difficult to predict who might
be able to listen. Internet traffic between buildings just a few hundred
meters apart have been observed temporarily being routed through half a
dozen countries, perhaps a few thousand kilometers.

And even without routing anomalies, it is possible that the enemy has
been able to take control of some nearby machine, and can listen in from
there. Of course, passive eavesdropping is most dangerous if you
transmit cleartext passwords. This is the main reason not to use vanilla
telnet to login to remote systems. Use a telnet with support for
@acronym{SSL} or Kerberos, or use a program like @code{lsh} or
@code{ssh}. 

A passive eavesdropper is assumed not to do anything nasty with your
packets beyond listening to them.

@item Name resolution attacks
The translation from symbolic @acronym{DNS} names to numeric
ip-addresses may be controlled by the attacker. In this case, you may
think that you are connecting to a friendly machine, when in fact you
are connecting somewhere else.

@item Fake packets
It is fairly easy to fake the source address of an @acronym{IP}-packet,
although it is more difficult to get hold on the replies to the faked
packets. But even without any replies, this cause cause serious
problems. 

@item @dfn{Man-in-the-middle} attack
In this attack, the enemy sits between you and the target. When
communicating with you, he pretends to be the target. When communicating
with the target, he pretends to be you. He also passes all information
on more or less unmodified, so that he is invisible to you and the
target. To mount this attack, the enemy either needs physical access to
some network equipment on the path between you and the target, or he has
been able to fool you to connect to him rather than to the target, for
example by manipulating the @acronym{DNS}-system.

@end table

@code{lsh} makes no attempt to protect you from local attacks. You have
to trust the endpoint machines. It seems really difficult to uphold any
security if the local machine is compromised. This is important to keep
in mind in the ``visitor''-scenario, where you visit a friend or perhaps an
internet café and want to connect to some of the machines at home or at
work. If the enemy has been able to compromize your friend's or the
café's equipment, you may well be in trouble.

Protection from denial of service attacks is also a very difficult
problem, and @dfn{lsh} makes no attempt to protect you from that.

Instead, the aim of @dfn{lsh}, and most serious tools for cryptographic
protection of communications across the net, is to isolate the
vulnerabilities to the communication endpoints. If you know that the
endpoints are safe, the enemy should not be able to compromize your
privacy or communications. Except for denial of service attacks (which
at least can't be performed without you noticing it).

First of all, @dfn{lsh} provides protection against passive
eavesdropping. In addition, if you take the appropriate steps to make
sure that hostkeys are properly authenticated, @dfn{lsh} also protects
against man-in-the-middle attacks and in particular against attacks on
the name resolution. In short, you need only trust the security at the
end points: Even if the enemy controls all other network equipment, name
resolution and routing infrastructure, etc, he can't do anything beyond
the denial of service attack.

And at last, remember that there is no such thing as absolute security.
You have to estimate the value of that which you are protecting, and
adjust the security measures so that your enemies will not find it worth
the effort to break them.


@node Features, Related techniques, Threats, Introduction
@comment  node-name,  next,  previous,  up
@section Other convenient features

@code{lsh} does not only provide more secure replacements for
@code{telnet}, @code{rsh} and @code{rlogin}, it also provides some other
features to make it convenient to communicate securely. But @code{lsh} is
still in an early stage of development, so this section is expected to
grow with time. One goal for @code{lsh} is to make it reasonable easy to
extend it, without messing with the core security functionality.

@code{lsh} can be configured to allow login based on a personal key-pair
consisting of a private and a public key, so that you can execute remote
commands without typing your password every time. Other user
authentication methods on the wish list include Kerberos support and
authentication using Thomas Wu's Secure Remote Password Protocol (SRP).

The public-key authentication methods should also be extended to support
Simple Public Key Infrastructure (SPKI) certificates, including some
mechanism to delegate restricted logins.

Forwarding of arbitrary tcp/ip connections is provided. This is useful
for tunneling otherwise insecure protocols, like telnet and pop, through
an encrypted @code{lsh} connection.

Convenient tunneling of X is one of the most impressive features of the
original @code{ssh} programs. @code{lsh} doesn't do this yet. Other kind
of tunneling that may turn out to be useful include authentication (i.e.
@code{ssh-agent}), general forwarding of @acronym{UDP}, and why not also
general ip-tunneling.


@node Related techniques,  , Features, Introduction
@comment  node-name,  next,  previous,  up
@section Related programs and techniques

This sections describes some other programs and techniques related to
@code{lsh}. The ssh family of programs use mostly the same kind of
security as @code{lsh}. Kerberos and @acronym{IPSEC} operate quite
differently, in particular when it comes to protection against
Man-in-the-middle attacks.

@menu
* ssh1::                        SSH version 1
* ssh2::                        SSH version 2
* Kerberos::                    Kerberos
* ipsec::                       IP Sec
@end menu

@node ssh1, ssh2, Related techniques, Related techniques
@comment  node-name,  next,  previous,  up
@subsection ssh-1.x

The first of the Secure shell programs was Tatu Ylonen's @code{ssh}. The
latest of the version 1 series is @code{ssh-1.27} which speaks version
1.5 of the protocol. The ``free'' version of ssh-1.27 does not allow
commercial use without additional licensing, which makes ssh-1.27
non-free software according to the Debian's Free Software Guidelines and
the Open Source Definition.

The version 1 protocol has some minor weaknesses, in particular, all
support for using stream ciphers was disabled by default a few versions
back, for security reasons.

There also exists free implementations of ssh-1, for both Unix and
Windows.

Until @code{lsh} becomes stable and well tested, I would recommend using
some implementation of the ssh-1 protocol.

@node ssh2, Kerberos, ssh1, Related techniques
@comment  node-name,  next,  previous,  up
@subsection ssh-2.x

@code{ssh-2} implements the next generation of the Secure Shell
protocol, the development of which is supervised by the @acronym{IETF}
secsh Working Group, although that working groups doesn't seem to be
very active now. @code{lsh} implements the required subset of this
protocol. It is intended to be compatible with the @code{ssh-2} series
of programs distributed by Datafellows.

However, the existing versions of @code{ssh-2} gets some details of the
protocol wrong (probably because it predates the protocol
specification), so there is some amount of bug-compatibility required.

Interoperability between independenly developed implementations is one
necessary condition for the ssh-2 protocol to become a Proposed
Standard.

The license for Datafellow's @code{ssh-2} programs is similar to that
for recent versions of @code{ssh-1}, but with a narrower definition of
``non-commercial use''.

@node Kerberos, ipsec, ssh2, Related techniques
@comment  node-name,  next,  previous,  up
@subsection Kerberos

Kerberos is a key distribution system originally developed in the late
1980:s as a part of Project Athena at @acronym{MIT}. Recent development
have been done at The Royal Institute of Technology, Stockholm
(@acronym{KTH}).

Kerberos uses a central trusted ticket-granting server, and requires
less trust on the local machines in the system. It does not use
public-key technology.

Usually, Kerberos support is compiled into applications such as telnet,
ftp and X-clients. The ssh family of programs, on the other hand, tries
to do all needed magic, for instance to forward X securely, and then
provides general tcp forwarding as a kitchen sink.

I think Kerberos' and lsh's protection against passive eavesdropping are
mostly equivalent. The difference is in the set of machines and
assumptions you have to trust in order to be safe from a
man-in-the-middle attack.

I think the main advantage of @code{lsh} over Kerberos is that it is
easier to install and use for on ordinary mortal user. In order to set
up key exchange between two different Kerberos systems (or @dfn{Kerberos
realms}), the respective system operators need to exchange keys. In the
case of two random users at two random sites, setting up @code{lsh} or
some other program in the ssh family is likely easier than to get the
operators to spend time and attention. So @code{lsh} should be easier to
use in a anarchistic grass-roots environment.

Another perspective is to combine ssh-features like X and @acronym{TCP}
forwarding with authentication based on Kerberos. Such an arrangement
may provide the best of two worlds for those who happen to have an
account at a suitable ticket-granting server.

@node ipsec,  , Kerberos, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @acronym{IPSEC}

@acronym{IPSEC} is a set of protocols for protecting general ip-traffic.
It is developed by anotheer @acronym{IETF} working group, and is also a
required part of IP version 6.

Again, the main difference between @acronym{IPSEC} and Kerberos and ssh
is the set of machines that have to be secure and the keys that have to
be exchanged in order to avoid man-in-the-middle attacks.

Current protocols and implementations of @acronym{IPSEC} only provide
authentication of machines; there's nothing analogous to the user
authentication in ssh or Kerberos.

On the other hand, @acronym{IPSEC} provides one distinct advantage over
application level encryption. Because @acronym{IP} and @acronym{TCP}
headers are authenticated, it provides protection against some
denial-of-service attacks. In particular, it makes attacks that cause
hangup of a @acronym{TCP} connection considerably more difficult.

So it makes sense to use both @acronym{IPSEC} and some application
level cryptographic protocol.

Also note that it is possible to use the @dfn{Point-to-Point} PPP
protocol to tunnel arbitrary ip traffic accross an ssh connection. This
arrangement provides some of the functionality of @acronym{IPSEC}, and
is some times referred to as ``a poor man's Virtual Private Network''.

@node Installation, Getting started, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter Installation

You install @code{lsh} with the usual @samp{./configure && make &&
make install}. For a full listing of the options you can give to
@code{configure}, use @samp{./configure --help}. For example, use
@option{--without-pty} to disable pty-support.

The most commonly used option is @option{--prefix}, which tells
configure where lsh should be installed. Default prefix is
@file{/usr/local}. The @code{lshd} server is installed in
@file{$prefix/sbin}, all other programs and scripts are installed in
@file{$prefix/bin}. 

The configure script is not very smart about dynamically linked
libraries in non-standard places. If, for example, you have a
@file{zlib.so} installed in @file{/somewhere/lib}, you may need to run

@samp{LDFLAGS="-R/somwhere/lib" ./configure}

to get linking right. Or use @env{LD_LIBRARY_PATH} at runtime.

@node Getting started, Invoking lsh, Installation, Top
@comment  node-name,  next,  previous,  up
@chapter Configuring @code{lshd}

There are no global configuration files for @code{lshd}; all
configuration is done with command line switches @xref{Invoking lshd}.

To run @code{lshd}, you must first create a hostkey, usually stored in
@file{/etc/lsh_host_key}. To do this, run

@samp{lsh_keygen | lsh_writekey /etc/lsh_host_key}

This will also create a file @file{/etc/lsh_host_key.pub},
containing the corresponding public key.

A typical command line for starting lshd in daemon mode is simply

@samp{lshd --daemonic}

It is also possible to let @code{init} start lshd, by adding in in
@file{/etc/inittab}.

@node Invoking lsh, Invoking lshd, Getting started, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @code{lsh}

You use @code{lsh} to login to a remote machine. Basic usage is

@samp{lsh [-p @var{port number}] sara.lysator.liu.se}

which attempts to connect, login, and start an interactive shell on the
remote machine. Default @var{port number} is whatever your system's
@file{/etc/services} lists for @code{ssh}. Usually, that is port 22.

There is a plethora of options to @code{lsh}, to let you configure where
and how to connect, how to authenticate, and what you want to do once
properly logged in to the remote host. Many options have both long and
short forms. This manual does not list all variants; for a full listing
of supported options, use @samp{lsh --help}.

@menu
* Algorithms: Algorithm options.  Selecting algorithms.
* Hostauth options::            
* Userauth options::            
* Actions: Action options.      What to do after login.
* Messages: Verbosity options.  Tuning the amount of messages.
@end menu

@node Algorithm options, Hostauth options, Invoking lsh, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Algorithm options

Before a packet is sent, each packet can be compressed, encrypted
and authenticated, in that order. When the packet is received, it is
first decrypted, next it is checked that it is authenticated properly,
and finally it is decompressed. The algorithms used for this are
negotiated with the peer at the other end of the connection, as a part
of the initial handshake and key exchange.

Each party provides a list of supported algorithms, and the first
algorithm listed by the client, which is also found on the server's
list, is selected. Note that this implies that order in which algorithms
are listed on the server's list doesn't matter: if several algorithms
are present on both the server's and the client's lists, it's the
client's order that determines which algorithm is selected.

Algorithms of different types, e.g. data compression and message
authentication, are negotiated independently. Furthermore, algorithms
used for transmission from the client to the server are independent of
the algorithms used for transmission from the server to the client.
There are therefore no less than six different lists that could be
configured at each end.

The command line options for lsh and lshd don't let you specify
arbitrary lists. For instance, you can't specify different preferences
for sending and receiving.

There is a set of default algorithm preferences. When you use a command
line option to say that you want to use @var{algorithm} for one of the
algorithms, the default list is replaced with a list containing the
single element @var{algorithm}. For example, if you use @option{-c
arcfour} to say that you want to use @code{arcfour} as the encryption
algorithm, the connection will either end up using @code{arcfour}, or
algorithm negotiation will fail because the peer doesn't support
@code{arcfour}.

@multitable @columnfractions 0.1 0.2 0.2 0.5
@item Option
  @tab Algorithm type @tab Default @tab
@item @option{-z} @tab Data compression
  @tab @code{none}, @code{zlib}

  @tab The default preference list supports zlib compression, but
prefers not to use it. 

@item @option{-c} @tab Encryption
  @tab @code{3dec-cbc}, @code{blowfish-cbc}, @code{cast128-cbc},
@code{twofish-cbc}, @code{arcfour}

  @tab The default encryption algorithm is tripple-DES in CBC mode. This
seems to be the algorithm of choice among conservative cryptographers.

@item @option{-m} @tab Message Authentication
  @tab @code{hmac-sha1}, @code{hmac-md5}

  @tab Both supported message authentication algorithms are of the
@acronym{HMAC} family.
@end multitable

As a special case, @option{-z} with no argument changes the compression
algorithm list to @code{zlib}, @code{none}, which means that you want to
use @code{zlib} if the other end supports it. This is different from @option{-z
zlib} which causes the negotiation to fail if the other end doesn't
support @code{zlib}.


@node Hostauth options, Userauth options, Algorithm options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Host authentication options

As described earlier @pxref{Threats}, proper authentication of the
remote host is crucial to protect the connection against
Man-in-the-middle attacks. By default, @code{lsh} verifies the server's
claimed host key against the @dfn{Access Control Lists} in
@file{~/.lsh/known_hosts}. If the remote host cannot be authenticated,
the connection is dropped.

The options that change this behaviour are

@table @option
@item --host-db
Specifies the location of the @acronym{ACL} file.

@item --sloppy-host-authentication
Tell @code{lsh} not to drop the connection if the server's key can not
be authenticated. Instead, it display the fingerprint of the key, and
ask if it is trusted. The received key is also appended to the file
@file{~/.lsh/captured_keys}. If run in quiet mode, @samp{lsh -q
--sloppy-host-authentication}, @code{lsh} connects to any host, no
questions asked.

@item --strict-host-authentication
Disable sloppy operation (this is the default behaviour).

@item --capture-to
Use some other file than @file{~/.lsh/captured_keys}. For example,
@samp{--sloppy-host-authentication --capture-to ~/.lsh/known_hosts}
makes @code{lsh} behave more like the @code{ssh} program.

@end table

@node Userauth options, Action options, Hostauth options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section User authentication options

@table @option

@item -l
Provide a name to use when logging in. By default, the value of the
@env{LOGNAME} variable is used.

@item -i
Try the keys from this file to log in. By default, @code{lsh} uses
@file{~/.lsh/identity}, if it exists. It ought to be possible to use
several @option{-i} options to use more than one file, but that is
currently not implemented.

@item --no-publickey
Don't attempt to log in using public key authentication.

@end table

@node Action options, Verbosity options, Userauth options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Action options

There are many things @code{lsh} can do once you are logged in. There
are two types of options that control this: @dfn{actions} and
@dfn{action modifiers}. For short options, actions use uppercase letters
and modifiers use lowercase.

For each modifier @option{--foo} there's also a negated form
@option{--no-foo}. Options can also be negated be preceding it with the
special option @option{-n}. This is mainly useful for negating short
options. For instance, use @option{-nt} to tell @code{lsh} not to
request a remote pseudo terminal. Each modifier and its negation can be
used several times on the command line. For each action, the latest
previous modifier of each pair apply.

First, the actions:

@table @option

@item -L
Requests forwarding of a local port. This option takes mandatory
argument of the form
@var{listen-port}:@var{target-host}:@var{target-port}. This option tells
@code{lsh} to listen on @var{listen-port} on the local machine. When
someone conects to that port, @code{lsh} asks the remote server to open
a connection to @var{target-port} on @var{target-host}, and if it
succeeds, the two connections are joined together through an the
@code{lsh} connection. Both port numbers should be given in decimal.

@item -R
Requests forwarding of a remote port. It takes one mandatory argument,
just like @option{-L}. But in this case @code{lsh} asks the
@emph{remote} server to listen on @var{listen-port}. When someone
connects to the remote hosts, the server will inform the local
@code{lsh}. The local @code{lsh} then connects to @var{target-port} on
@var{target-host}.

@item -E
This option is not yet implemented. It takes one mandatory argument,
which is a command to be executed on the remote machine.

@item -S
Start a shell on the remote machine. Currently not implemented, except
as the default action.

@item -N
This is a no-operation action. It inhibits the default action, which is
to start an interactive shell on the remote machine. It is useful if you
want to set up a few forwarded tunnels, and nothing more.

@end table

If there are trailing arguments after the name of the remote system,
this is equivalent to a @option{-E} option, with a command string
constructed by taking all the remaining arguments, separated by spaces.
This implies that the arguments are usually expanded first by the local
shell, and then the resulting command string is interpreted again by the
remote system. In any case, just like @option{-E}, this is not yet
implemented.

If there are no trailing arguments after the name of the remote system,
and the @option{-N} option is not given, the default action is to start
a shell on the remote machine. I.e. this is equivalent to the
@option{-S} option.

There are a few supported modifiers:

@table @option

@item -t
Request a pseudo terminal. @code{lsh} asks the remote system to allocate
a pseudo terminal. If it succeeds, the local terminal is set to raw
mode. The default behaviour is to request a pty if and only if the
local @code{lsh} process has a controlling terminal. This modifier
applies to actions that create remote processes, i.e. @option{-E} and
@option{-S}, as well as the default actions.

Currently, this option is ignored if there is no local terminal.

@item -g
Gateway mode. This option applies to the forwarding actions, i.e.
@option{-L} and @option{-R}. By default, only connections to the
loopback interface, ip 127.0.0.1, are forwared. This implies that only
processes on the same machine can use the forwarded tunnel directly. If
the -g modifier is in effect, the forwarding party will listen on
@emph{all} network interfaces.

@end table

@node Verbosity options,  , Action options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Verbosity options

These options determines what messages @code{lsh} writes on
its stderr.

@table @option

@item -q
Quiet mode. Disables all messages and all questions. Except password
prompts and fatal internal errors.

@item -v
Verbose mode. Makes @code{lsh} a little more verbose. The intention is
to provide information that is useful for ordinary trouble shooting,
and makes sense also to those not familiar with @code{lsh} internals.

@item --trace
Trace mode. Prints some internal information to aid tracking
lsh's flow of control.

@item --debug.
Debug mode. Dumps @emph{a lot} of information, including dumps of all
sent and received packets. It tries to avoid dumping highly sensitive data,
such as private keys and the contents of @code{SSH_MSG_USERAUTH_REQUEST}
messages, but you should still use it with care.

@end table

@node Invoking lshd, Terminology, Invoking lsh, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @code{lshd}

@code{lshd} is a server that accepts connections from clients speaking
the Secure Shell Protocol. It is usually started automatically when the
systems boots, and runs with root privileges. However, it is also
possible to start lshd manually, and with user privileges.

There is currently no configuration files. Instead, command line options
are used to tell @code{lshd} what to do. Many options have @option{--foo}
and @option{--no-foo} variants. Options specifying the default behaviour
are not listed here.

Some of the options are the shared with @code{lsh}. In particular, see
@ref{Algorithm options} and @ref{Verbosity options}.

Options specific to the @code{lshd} server are:

@table @option

@item -p
Port to listen to. The mandatory argument is a decimal port number or a
service name. Default is "ssh", usually port 22.

@item --interface
Network interface to listen on. By default, @code{lshd} listens on all
interfaces.

@item -h
Location of the server's private key file. By default,
@file{/etc/lsh_host_key}.

@item -i
Variant of the s-expression syntax to use when reading the host key.
Default is to use transport format. Not a terribly useful option.

@item --ssh1-fallback
This options enables fallback to @code{ssh1}. @code{lshd} doesn't
implement version 1 of the Secure Shell Protocol. But it can fork an ssh1
server when an old client connects. Falling back to ssh1 is inefficient,
and requires some special features of the server fallen back to. It
should work with the sshd daemon supplied with reasonably new versions of
Datafellow's @code{sshd1}, and with @code{openssh}.

The optional argument provides the filename of the ssh1 daemon to use.
Default name is @file{/usr/local/sbin/sshd1}, unless something else was
configured at compile time.

@item --daemonic
Enables daemonic mode. @code{lshd} forks into the background, redirects
its stdio handles to @file{/dev/null}, changes its working directory to
@file{/}, and redirects any diagnostic or debugging messages via syslog.

@code{lshd} should be able to deal with the environment it inherits if it
is started by @code{init} or @code{inetd}, but this is not really tested.

@item --pid-file
Creates a locked pid file, to make it easier to write start and stop
scripts for @code{lshd}. The mandatory argument provides the filename.
This option is enabled by default when operating in daemonic mode, and
the default filename is @file{/var/run/lshd.pid}.

@item --enable-core
By default, @code{lshd} disables core dumps, to avoid leaking sensitive
information. This option changes that behaviour, and allows @code{lshd}
to dump core on fatal errors.

@item --no-password
Disable the "password" user authentication mechanism. 

@item --no-publickey
Disable the "publickey" user authentication mechanism.

@item --root-login
Enable root login. By default, root can not log in using @code{lshd}.

@item --no-pty-support
Disable support for pseudo terminals.

@item --no-tcp-forward
Disable support for tcp forwarding, in both directions.

@end table


@node Terminology, Concept Index, Invoking lshd, Top
@comment  node-name,  next,  previous,  up
@chapter Terminology

@node    Concept Index,  , Terminology, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp

@contents

     
@bye
