dnl -*- mode: shell-script; sh-indentation: 2; -*-
dnl $Id$

dnl Process this file with autoconf to produce a configure script.
AC_INIT(src/lsh_types.h)

dnl No real versioning yet, use dated snapshots instead.
dnl AM_INIT_AUTOMAKE(lsh, snapshot-`date +%Y-%m-%d`)
AM_INIT_AUTOMAKE(lsh, esyscmd([date +snapshot-%Y-%m-%d]))

AM_CONFIG_HEADER(config.h)

# We want an absolute path to the source-dir.
case "$srcdir" in
    /*)
    ;;
    *)
	oldsrcdir="$srcdir"
	srcdir="`cd \"$srcdir\";pwd`"
	AC_MSG_WARN([ Converted $oldsrcdir to $srcdir,
If this does not work, please use an absolute path to the configure script. ])
    ;;
esac

# We want to compile the crypto lib for use with lsh
CPPFLAGS="$CPPFLAGS -I$srcdir -I$srcdir/src -I$srcdir/src/symmetric/include -DLSH"

# GNU libc defaults to supplying the ISO C library functions only. 
# initgroups() and strsignal() are extensions; the _GNU_SOURCE define
# enables these extensions.
# Enable it on all systems; no problems have been reported with it so far.

CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"

dnl Check options
AC_ARG_WITH(debug_alloc,
  [--with-debug-alloc    sanity check memory allocation and casts],,
  [with_debug_alloc=yes])

if test x$with_debug_alloc = xyes ; then
  AC_DEFINE(DEBUG_ALLOC)
fi

AC_ARG_WITH(zlib,
  [--with-zlib    use zlib compression],,
  [with_zlib=yes])

dnl Checking this variable is delayed until we have checked if zlib is
dnl actually available.

AC_ARG_WITH(pty,
  [--without-pty   disable pty support],,
  [with_pty=yes])

if test x$with_pty = xyes ; then
  AC_DEFINE(WITH_PTY_SUPPORT)
fi

AC_ARG_WITH(sshd1,
  [--with-sshd1[=PROGRAM]    support fallback to SSH1 daemon],,
  [with_sshd1=yes])

# Default sshd1 path
if test x$with_sshd1 = xyes ; then
  with_sshd1=/usr/local/sbin/sshd1
fi

if test x$with_sshd1 != xno ; then
  AC_DEFINE(WITH_SSH1_FALLBACK)
  AC_DEFINE_UNQUOTED(SSHD1,"$with_sshd1")
fi

AC_ARG_WITH(idea,
  [--with-idea    support the patent-encumbered IDEA algorithm],,
  [with_idea=no])

if test x$with_idea = xyes ; then
  AC_DEFINE(WITH_IDEA)
fi

dnl Checks for programs.
AC_PROG_CC
AC_PROG_MAKE_SET
AC_PROG_RANLIB
AM_PROG_CC_STDC

AC_PATH_PROG(SCHEME, scsh,, $PATH)
AC_PATH_PROG(BASH, bash,, $PATH)
AC_PATH_PROG(GROFF, groff,, $PATH)

if test x$am_cv_prog_cc_stdc = xno ; then
  AC_ERROR([the C compiler doesn't handle ANSI-C])
fi

dnl Checks for libraries.
AC_CHECK_LIB(gmp, mpz_set_d,,
dnl Some debian systems have both gmp1 and gmp2.
    [AC_CHECK_LIB(gmp2, mpz_set_d,,
	AC_ERROR([GMP is missing (ftp://ftp.gnu.org/pub/gnu/gmp-2.0.2.tar.gz)]))])

if test x$with_zlib = xyes; then
  AC_CHECK_LIB(z, inflate,, [with_zlib=no])
fi
AC_CHECK_LIB(crypt, crypt)
AC_CHECK_LIB(xnet, inet_addr)
AC_CHECK_LIB(nsl, gethostbyname)
AC_CHECK_LIB(socket, setsockopt)
AC_CHECK_LIB(openpty, util)
AC_SEARCH_LIBS(syslog, bsd socket inet)

dnl Checks for header files.
AC_HEADER_STDC

dnl Some debian systems have both gmp and gmp2.
dnl This will probably not work right if both gmp.h and gmp2/gmp.h exists,
dnl and gmp.h is too old (i.e GMP-1.x).
gmp_header_found=no
AC_CHECK_HEADERS(gmp.h gmp2/gmp.h, [gmp_header_found=yes; break])
if test "$gmp_header_found" = no; then
  AC_ERROR([Neither gmp.h nor gmp2/gmp.h found])
fi
  
AC_CHECK_HEADERS(fcntl.h strings.h sys/time.h unistd.h)
AC_CHECK_HEADERS(shadow.h)
if test x$with_zlib = xyes; then
  AC_CHECK_HEADERS(zlib.h,, [with_zlib=no])
fi
AC_CHECK_HEADERS(poll.h sys/poll.h)
AC_CHECK_HEADERS(crypt.h)
AC_CHECK_HEADERS(pty.h)
AC_CHECK_HEADERS(stropts.h)

AC_CHECK_HEADERS(utmp.h, [have_utmp_h=yes], [have_utmp_h=no])
if test x$have_utmp_h = xyes; then
  AC_CACHE_CHECK(
    [if struct utmp has a ut_host member],
    lsh_cv_decl_utmp_have_ut_host,
    AC_TRY_COMPILE(utmp.h,
      [ int foo() { struct utmp u; u.ut_host[0] = 'X'; return 0; } ],
      lsh_cv_decl_utmp_have_ut_host=yes,
      lsh_cv_decl_utmp_have_ut_host=no))
      
  if test x$lsh_cv_decl_utmp_have_ut_host = xyes; then
    AC_DEFINE(HAVE_UT_HOST)
  fi
  AC_CACHE_CHECK(
    [if struct utmp has a ut_addr member],
    lsh_cv_decl_utmp_have_ut_addr,
    AC_TRY_COMPILE(utmp.h,
      [ int foo() { struct utmp u; u.ut_addr[0] = 'X'; return 0; } ],
      lsh_cv_decl_utmp_have_ut_addr=yes,
      lsh_cv_decl_utmp_have_ut_addr=no))

  if test x$lsh_cv_decl_utmp_have_ut_addr = xyes; then
    AC_DEFINE(HAVE_UT_ADDR)
  fi
fi

dnl Should we use zlib?

if test x$with_zlib = xyes ; then
  AC_DEFINE(WITH_ZLIB)
fi

dnl Find the SSH1 daemon; try 'sshd1' first; if it fails, look for 'sshd'
dnl ## if test x$with_sshd1 = xyes ; then
dnl ## 	 AC_DEFINE(SSH1_FALLBACK)
dnl ## 	 dnl We have to provide an additional path: regular users seldomly have
dnl ## 	 dnl the sbin directories in their $PATH.
dnl ## 	 AC_PATH_PROG(SSHD1BIN, sshd1, [],
dnl ## 	   $PATH:/usr/local/sbin:/usr/local/etc:/usr/sbin:/usr/etc:/sbin:/etc)
dnl ## 	 if test x$SSHD1BIN = x ; then
dnl ## 	   AC_PATH_PROG(SSHD1BIN, sshd, [],
dnl ## 	     $PATH:/usr/local/sbin:/usr/local/etc:/usr/sbin:/usr/etc:/sbin:/etc)
dnl ## 	 fi
dnl ## 	 if test x$SSHD1BIN = x ; then
dnl ## 	   AC_MSG_ERROR([
dnl ## You requested SSH1 fallback support (--with-sshd1), but no sshd1 could be found.
dnl ## You can
dnl ## - supply the location of sshd1, i.e. --with-sshd1=/home/foo/sbin/sshd ,
dnl ## - install sshd1 (ftp://ftp.cs.hut.fi/pub/ssh/); note that it is not free
dnl ## 	 software, or
dnl ## - configure --without-sshd1 .
dnl ## ])
dnl ## 	 fi
dnl ## 
dnl ## 	 dnl OK. We've found an SSH1 daemon. Now we need to make sure it is
dnl ## 	 dnl recent enough to be used as a fallback daemon. This means it has to
dnl ## 	 dnl support the -V option, which tells it not to read the client version 
dnl ## 	 dnl string as lshd has already done that, and which supplies that version
dnl ## 	 dnl string.
dnl ## 	 AC_MSG_CHECKING(if $SSHD1BIN has the -V compatibility flag)
dnl ## changequote(<<, >>)dnl
dnl ## 	 if ($SSHD1BIN -h 2>&1 ; true) | grep '^[ \t]*-V' > /dev/null ; then
dnl ## changequote([, ])dnl
dnl ## 	   AC_MSG_RESULT(yes)
dnl ## 	 else
dnl ## 	   AC_MSG_ERROR([
dnl ## Found SSH1 daemon ]$SSHD1BIN[, but it does not support the -V option.
dnl ## This means we cannot use it as a fallback daemon. Please install a more recent 
dnl ## SSH1 daemon (ftp://ftp.cs.hut.fi/pub/ssh/), or configure --without-sshd1 .])
dnl ## 	 fi
dnl ## 	 AC_DEFINE_UNQUOTED(SSHD1,"$SSHD1BIN")
dnl ## fi

dnl Checks for typedefs, structures, and compiler characteristics.
AC_C_CONST
AC_TYPE_UID_T
AC_TYPE_SIZE_T
AC_HEADER_TIME

AC_CHECK_SIZEOF(short, 2)
AC_CHECK_SIZEOF(int, 4)
AC_CHECK_SIZEOF(long, 4)
dnl FIXME: We should check that a pid_t fits in an int
	
dnl Checks for library functions.
AC_FUNC_ALLOCA
AC_FUNC_MEMCMP
AC_FUNC_VPRINTF
AC_CHECK_FUNCS(select socket strerror strtol)
AC_CHECK_FUNCS(getspnam)
AC_CHECK_FUNCS(vsnprintf inet_aton)
AC_CHECK_FUNCS(openpty)
AC_CHECK_FUNCS(cfmakeraw)
AC_FUNC_GETPGRP
AC_CHECK_FUNCS(syslog)
AC_REPLACE_FUNCS(memxor)

AC_CHECK_FUNCS(poll,,[LIBOBJS="jpoll.o $LIBOBJS"])

dnl This macro is mentioned in the automake manual, but where is it
dnl supposed to be defined?
dnl AC_REPLACE_GNU_GETOPT

AC_CHECK_FUNCS(getopt_long,,[LIBOBJS="getopt.o getopt1.o $LIBOBJS"])

dnl Check for broken shutdown
AC_CACHE_CHECK(for working shutdown on AF_UNIX sockets,
	       lsh_cv_func_shutdown_works_on_unix_sockets,
[
AC_TRY_RUN([
#include <stdio.h>

#include <errno.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <signal.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

/* Creates a one-way socket connection. Returns 1 on success, 0 on
 * failure. fds[0] is for reading, fds[1] for writing (like for the
 * pipe() system call). */
static int make_pipe(int *fds)
{

#ifndef SHUT_RD
#define SHUT_RD 0
#define SHUT_WR 1
#define SHUT_RDWR 2
#endif

  if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0)
    {
      fprintf(stderr, "socketpair() failed: %s\n", strerror(errno));
      return 0;
    }
  fprintf(stderr, "Created socket pair. Using fd:s %d <-- %d\n", fds[0], fds[1]);

  if(shutdown(fds[0], SHUT_WR) < 0)
    {
      fprintf(stderr, "shutdown(%d, SHUT_WR) failed: %s\n",
	      fds[0], strerror(errno));
      return 0;
    }
  if (shutdown(fds[1], SHUT_RD) < 0)
    {
      fprintf(stderr, "shutdown(%d, SHUT_RD) failed: %s\n",
	      fds[1], strerror(errno));
      return 0;
    }

  return 1;
}

int main(int argc, char **argv)
{
  int fds[2];
  
  if (!make_pipe(fds))
    exit(1);

  if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
    {
      fprintf(stderr, "signal failed.\n");
      exit(1);
    }

  if ( (write(fds[1], "foo", 3) < 0)
       && (errno == EPIPE))
    exit(1);

  exit(0);
}
], lsh_cv_func_shutdown_works_on_unix_sockets=yes,
   lsh_cv_func_shutdown_works_on_unix_sockets=no,
   lsh_cv_func_shutdown_works_on_unix_sockets=yes)])

if test x$lsh_cv_func_shutdown_works_on_unix_sockets = xyes ; then
    AC_DEFINE(SHUTDOWN_WORKS_WITH_UNIX_SOCKETS)
fi

AC_CACHE_CHECK(
  [for working UNIX98 ptys],
  lsh_cv_sys_unix98_ptys,
  AC_TRY_RUN([
  /* Try to obtain a working UNIX98-style pty master and slave */
  /* Based on example code from the GNU C library documentation */
  #include <stdlib.h>	/* EXIT_FAILURE, EXIT_SUCCESS, ptsname */
  #include <unistd.h>	/* close(2) */
  
  #include <sys/types.h>	/* open(2) */
  #include <sys/stat.h>	/* - " -   */
  #ifdef HAVE_FCNTL_H
  #  include <fcntl.h>	/* - " -   */
  #endif
  #ifdef HAVE_STROPTS_H
  #  include <stropts.h>	/* isastream() */
  #endif
  
  int main(int argc, char* argv[]) {
    int master, slave;
    char *name;
  
    master = open("/dev/ptmx", O_RDWR); /* PTY master multiplex */
    if (master < 0) {
  	  exit(EXIT_FAILURE);
    }
  
    if (grantpt(master) < 0 || unlockpt(master) < 0)
      goto close_master;
    name = ptsname(master);
    if (name == NULL)
      goto close_master;
  
    slave = open(name, O_RDWR);
    if (slave == -1)
      goto close_master;
  
  #ifdef HAVE_STROPTS_H
    if (isastream(slave))
      {
  	if (ioctl(slave, I_PUSH, "ptem") < 0
  	    || ioctl(slave, I_PUSH, "ldterm") < 0)
  	  goto close_slave;
      }
  #endif
  
    exit(0);
  
  close_slave:
    close (slave);
  
  close_master:
    close (master);
    exit(1);
  }
  ],
  [lsh_cv_sys_unix98_ptys=yes],
  [lsh_cv_sys_unix98_ptys=no],
  dnl FIXME: Pessimistic default for cross compilation.
  [lsh_cv_sys_unix98_ptys=no]))

if test x$lsh_cv_sys_unix98_ptys = xyes; then
  AC_DEFINE(HAVE_UNIX98_PTYS)
fi
  
dnl Check for gcc's __attribute__ construction
AC_CACHE_CHECK(for __attribute__,
	       lsh_cv_c_attribute,
[ AC_TRY_COMPILE([
#include <stdlib.h>
],
[
static void foo(void) __attribute__ ((noreturn));

static void __attribute__ ((noreturn))
foo(void)
{
  exit(1);
}
],
lsh_cv_c_attribute=yes,
lsh_cv_c_attribute=no)])

if test "$lsh_cv_c_attribute" = "yes"; then
  AC_DEFINE(HAVE_ATTRIBUTE)
fi

AC_MSG_CHECKING(for BSD pty names)
AC_DEFINE_UNQUOTED(PTY_BSD_SCHEME_FIRST_CHARS, "`ls /dev/pty* | cut -c 9-9 | uniq | tr -d '\n'`")
AC_DEFINE_UNQUOTED(PTY_BSD_SCHEME_SECOND_CHARS, "`ls /dev/pty* | cut -c 10-10 | sort | uniq | tr -d '\n'`")

dnl FIXME: How can we test if the bsd scheme is likely to work?
AC_DEFINE(PTY_BSD_SCHEME)
AC_MSG_RESULT([done])

# Set these flags *last*, or else the test programs won't compile
if test x$GCC = xyes ; then
    CFLAGS="$CFLAGS -Wall -W \
 -Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes \
 -Waggregate-return \
 -Wpointer-arith -Wbad-function-cast -Wnested-externs"

# Don't enable -Wcast-align as it results in tons of warnings in the
# DES code. And when using stdio.

fi

AC_OUTPUT(Makefile doc/Makefile misc/Makefile
	  src/Makefile src/symmetric/Makefile src/symmetric/include/Makefile)
