ERROR HANDLING

Consider return values from handlers. A return value has several
components:

 x Success/failure indication
 
 x Next action (continue, close immediately, flush buffers then close,
   exit...)
 
 x Process return value in case the proper action is to exit.

It should be possible to encode all this information into a simple
integer. And some actions are orthogonal. For instance, a handler may
fork, and send a few messages. Now, both the fork action and any error
codes from writing must be taken care of.


KEYS

Code is needed to generate, store and read dss keys. Preferably in a
SPKI/s-expression form.


USERS

Functions to lookup users, their passwords and .lsh/authorized_keys.


CHARSETS

Usernames and passwords must be translated from the systems charset
(default iso-8859-1) to UTF8.


CONFIGURATION

Read configuration files. Better command line options.


LEAKS

Not all packet consumers free processed packets properly.

Use separate allocation function for objects that are subject to gc,
and thos (for instance, strings and atom lists) which are deallocated
explicitly). 

Implement a mark&sweep gc.


IO

Add flow control to the generic io class. Associate a "window size"
with each read fd, and refuse to accept any more data. That seems
cleaner than doing all flow control at the channel level.


CHANNELS

Create some generic methods for connecting a channel to one or more
files. The data shuffling and error handling should be very similar
for most channel types.

Consider which errors can occur in the channel callback functions;
they are probably somewhat different from errors in higher levels. For
instance, a writing to a file associated with a channel may fail. In
that case, the channel should be closed, but the connection should not
die. Perhaps a few special error codes like LSH_CHANNEL_DIE and
LSH_CHANNEL_CLOSED would do the trick?
