This file contains notes that don't fit in the TODO or TASKLIST files.


NO PAM SUPPORT

I spent a day reading the PAM documentation. My conclusion was that
PAM is not at all suited for handling ssh user authentication. There
are three main problems, the first two of which would be show-stoppers
for any SSH server, while the last is a problem that affects servers
like lshd which doesn't fork() for each connection.

(i) The design of PAM is to hide all details about the actual
authentication methods used, and that the application should never
know anything about that. However, ssh user authentication is about
particular authentication methods. When the client asks which
authentication methods can be used, the server should be able to tell
it, for example, whether or not password authentication is acceptable.
When the client tries the password authentication method, no other
method should be invoked. But PAM won't let the server know or control
such details. This problem excludes using PAM for anything but simple
password authentication.

(ii) PAM wants to talk directly to the user, to ask for passwords,
request password changes, etc. These messages are not abstracted *at*
*all*, PAM gives the application a string and some display hints, and
expects a string back as the users response. This mode of operation
doesn't fit with the ssh user-authentication protocol. 

If PAM would tell the ssh server that it wanted the user to chose a
new password, for instance, the server could the appropriate message,
SSH_SSH_MSG_USERAUTH_PASSWD_CHANGEREQ, to the client, and pass any
response back to PAM. But PAM refuses to tell the application what it
really wants the user to do, and therefore there's no way the server
can map PAM's messages to the appropriate SSH packets. This problem
excludes using PAM for password authentication.

(iii) The PAM conversation function expects the server to ask the user
some question, block until a response is received, and then return the
result to PAM. That is very unfriendly to a server using a select()
loop to manage many simultaneous tasks. This problem by itself does
not exclude using PAM for a traditional accept(); fork()-style server,
but it is completely unacceptable for lshd.


DSS KEY GENERATION

I have implemented DSS key generation, using the method recommended by
NIST (algorithm 4.56 of Handbook of Applied Cryptography) to generate
the public primes. According to Werner Koch, the method used in GNU
Privacy Guard, suggested by Lim-Lee at Crypto '97, may be a lot
faster:

> I generate a a pool of small primes (160 bits for a prime up to 1024
> bits), multiply a couple of them, then double the result, add 1 and
> check wether this is a prime (5 times Rabin-Miller) and continue
> with a new permutation until I found a prime. (p = 2*q*p1*p2 ... *
> pn + 1).


CLOSING CHANNELS

The right conditions for closing a channel, and in particular a
session, are somewhat subtle. There are three events that may happen
in arbitrary order:

(i) The client sends EOF on the channel.

(ii) The server sends EOF on the channel (this happens when there are
no more processes which have the files the server has opened for stdout
or stderr open).

(iii) The child process created by the server dies. An exit-status or
exit-signal message is sent to the client.

lshd handles these conditions as follows: It will not send a CLOSE
message until *all* the three events above have occurred. Naturally,
this could cause the channel to stay open for ever, for instance if
the child process has started a background job that happens to keep
its stdin open (perhaps without ever using it). In most cases this is
not what you want.

The lsh client will, by default, respond to exit-signal or exit-status
with an EOF message. If this is the last event keeping the server from
closing the channel, the channel is finally closed, on the server's
initiative.

It is conceivable that the user may want to continue communicating
with remaining child processes even after that the first process has
died (i.e. after that it has received exit-status or exit-signal from
the server). In this case, the client should be considered not to send
EOF until it detects EOF on stdin.


PTY REFERENCES (from Keresztg)

the code of tnlited
http://viks.mvrop.org/networking/sock_advanced_tut.html
Text-Terminal-HOWTO
http://www.developer.ibm.com/library/ref/about4.1/df4commo.html

Jon Ribbens <jon@oaktree.co.uk>:

The other functions can be found at
  ftp://ftp.openbsd.org/pub/OpenBSD/src/lib/libutil/pty.c



3605942 idag 07:59 /32 rader/ assar
Kommentar till text 3578895 av Niels Möller ()
Mottagare: C - (den) portabla(?) assemblern <7482>
Ärende: const
------------------------------------------------------------
tyvärr räcker inte det där eftersom det finns kompilatorer som är
(eller har varit i ett tidigare liv) gcc men inte förstår
__attribute__ för det.

så dår får man göra:

dnl
dnl Test for __attribute__
dnl

AC_DEFUN(AC_C___ATTRIBUTE__, [
AC_MSG_CHECKING(for __attribute__)
AC_CACHE_VAL(ac_cv___attribute__, [
AC_TRY_COMPILE([
#include <stdlib.h>
],
[
static void foo(void) __attribute__ ((noreturn));

static void __attribute__ ((noreturn))
foo(void)
{
  exit(1);
}
],
ac_cv___attribute__=yes,
ac_cv___attribute__=no)])
if test "$ac_cv___attribute__" = "yes"; then
  AC_DEFINE(HAVE___ATTRIBUTE__)
fi
AC_MSG_RESULT($ac_cv___attribute__)
])
(3605942) ------------------------------------------
