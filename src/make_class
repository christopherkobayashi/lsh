#! /usr/local/bin/scsh \
-e main -s
!#

;; Reads a C source file on stdin. Comments of the form
;;
;; /*
;; CLASS:
;;    expression
;; */
;;
;; are treated specially, and C code for the class is written to
;; stdout. Typically, the code is saved to a file and included by the
;; C source file in question.

;; FIXME: Perhaps the files should somehow be fed through the
;; preprocessor first?

(define (werror f . args)
  (display (apply format #f f args) 2))

(define (string-prefix? prefix s)
  (let ((l (string-length prefix)))
    (and (<= l (string-length s))
	 (string=? prefix (substring s 0 l)))))
    
(define (read-expression p)
  (let ((line (read-line)))
    ; (werror "read line: '~s'\n" (if (eof-object? line) "<EOF>" line))
    (cond ((eof-object? line) line)
	  ((p line) (read))
	  (else (read-expression p)))))

(define (get key alist select)
  (cond ((assq key alist) => select)
	(else #f)))

(define (append-deep o)
  ; (werror "append-deep: ~S\n" o)
  (cond ((string? o) o)
	((symbol? o) (symbol->string o))
	((number? o) (number->string o))
	(else
	 (apply string-append (map append-deep o)))))

(define (identity x) x)

(define (filter p list)
  (cond ((null? list) list)
	((p (car list)) (cons (car list)
			      (filter p (cdr list))))
	(else (filter p (cdr list)))))

(define (implode list separator)
  (cond ((null? list) '())
	((null? (cdr list)) list)
	(else `(,(car list) ,separator ,@(implode (cdr list) separator)))))

(define (atom? x) (or (symbol? x) (string? x)))

;; Variables are describes as lists (name . type)
;; Known types (and corresponding C declarations) are
;;
;; (string)          struct lsh_string *name
;; (object class)    struct class *name
;; (bignum)          mpz_t name
;; (simple c-type)   c-type
;; (special c-type mark-fn free-fn)
;;
;; (array type size) type name[size]
;;
;; (pointer type)    type *name
;; (space type)      Like pointer, but should be freed
;;
;; (function type . arg-types) type name(arg-types)
;;
;; NOTE: For function types, the arguments are represented simply as
;; strings or lists containing C declarations; they do not use the
;; type syntax.
;;
;; (method type args)
;; is transformed into (pointer (function type self-arg args)) before
;; processing,

(define (type->category type)
  (if (atom? type)
      (type->category `(simple ,type))
      (let ((tag (car type)))
	(case tag
	  ((string object simple special space bignum) tag)
	  ((array pointer) (type->category (cadr type)))
	  
	  (else (error "make_class: type->category: Invalid type" type))))))

(define (type->declaration type expr)
  (if (atom? type)
      (type->declaration `(simple ,type) expr)
      (case (car type)
	((string) (list "struct lsh_string *" expr))
	((object) (list "struct " (cadr type) " *" expr))
	((bignum) (list "mpz_t " expr))
	((simple special) (list (cadr type) " " expr))
	((pointer space) (type->declaration (cadr type)
					    (list "(*(" expr "))")))
	((array)  (type->declaration (cadr type)
				     (list "((" expr ")[" (caddr type) "])")))
	((function) (type->declaration (cadr type)
				       (list expr
					     "(" (implode (cddr type) ", ")
					     ")")))
	(else (error "make_class: type->declaration: Invalid type" type)))))

(define (type->mark type expr)
  (if (atom? type)
      (type->mark `(simple ,type) expr)
      (case (car type)
	((string simple function space bignum) #f)
	((object) (list "mark((struct lsh_object *) " expr ");\n"))
	((pointer) (type->mark (cadr type) (list "*(" expr ")")))
	((special) (let ((mark-fn (caddr type)))
		     (and mark-fn (list mark-fn "(" expr ", mark);\n"))))

	;; FIXME: Doesn't handle nested arrays
	((array)
	 (let ((mark-k (type->mark (cadr type) (list "(" expr ")[k]"))))
	   (and mark-k
		(list "{\n  unsigned k;\n"
		      "  for (k=0; k<" (caddr type) "; k++)\n"
		      "    " mark-k
		      "}\n"))))
	
	(else (error "make_class: type->mark: Invalid type" type)))))

(define (type->free type expr)
  (define (free/f f)
    (and f (list f "(" expr ");\n")))

  (if (atom? type)
      (type->free `(simple ,type) expr)
      (case (car type)
	((object simple function pointer) #f)
	((string) (free/f "lsh_string_free"))
	((bignum) (free/f "mpz_clear"))
	((space) (free/f "lsh_space_free"))
	((special) (free/f (cadddr type)))
    
	((array)
	 (let ((free-k (type->free (cadr type) (list "(" expr ")[k]"))))
	   (and free-k
		(list "{\n  unsigned k;\n"
		      "  for (k=0; k<" (caddr type) "; k++)\n"
		      "    " free-k
		      "}\n"))))
    
	(else (error "make_class: type->free: Invalid type" type)))))

(define (type->init type expr)
  (if (atom? type)
      (type->init `(simple ,type) expr)
      (case (car type)
	((object string space pointer) (list expr "= NULL;\n"))
	((bignum) (list "mpz_init(" expr ");\n"))
	((array)
	 (let ((init-k (type->init (cadr type) (list "(" expr ")[k]"))))
	   (and init-k
		(list "{\n  unsigned k;\n"
		      "  for (k=0; k<" (caddr type) "; k++)\n"
		      "    " init-k
		      "}\n"))))

	(else (error "make_class: type->init: Invalid type" type)))))
    
  
#!
(define var-category car)
(define var-type cadr)
(define var-name caddr)
(define var-extra cdddr)
(define var-args var-extra)
(define (var-marker x) (car (var-extra x)))
(define (var-freer x) (cadr (var-extra x)))

(define (c-declare type name)
  (if (pair? type)
      (let ((modifier (car type))
	    (base (cadr type))
	    (args (cddr type)))
	(case modifier
	  ((pointer)
	   (c-declare base (list "(* (" name "))")))
	  ((array)
	   (c-declare base (list "(" name ")[" (car args) "]")))
	  ((function)
	   (c-declare base (list "(" name ")(" (implode args ", ") ")")))
	  (else (list "#error UNKNOWN MODIFIER " modifier))))
      (list type " " name)))
!#

(define var-name car)
(define var-type cdr)

;; FIXME: Method declarations could be made more friendly. For instance
;; (method int name ("struct foo *arg")) rather than
;; (method (function int "struct this_type *self struct foo *arg") name)

(define (fix-method name var)
  (if (eq? 'method (cadr var))
      `(,(car var) pointer (function ,(caddr var) ("struct " ,name " *self")
				     ,@(cdddr var)))
      var))

(define (do-struct name super vars)
  (werror "do-struct\n")
  (list "struct " name 
	"\n{\n"
	"  struct " (or super "lsh_object") " super;\n"
	(map (lambda (var)
	       (list "  " (type->declaration (var-type var)
					     (var-name var)) ";\n"))
	     vars)
	"};\n"))

(define (do-mark-function name vars)
  (werror "do-mark-function\n")
  (let ((markers (filter identity
			 (map (lambda (var)
				(type->mark (var-type var)
					    (list "i->" (var-name var))))
			      vars))))
    (werror "gazonk\n")
    (and (not (null? markers))
	 (list "static void do_"
	       name "_mark(struct lsh_object *o, \n"
	       "void (*mark)(struct lsh_object *o))\n"
	       "{\n"
	       "  struct " name " *i = (struct " name " *) o;\n"
	       (map (lambda (x) (list "  " x))
		    markers)
	       "}\n\n"))))

(define (do-free-function name vars)
  (werror "do-free-function\n")
  (let ((freers (filter identity
			(map (lambda (var)
			       (type->free (var-type var) 
					   (list "i->" (var-name var))))
			     
			     vars))))
    (werror "gazonk\n")

    (and (not (null? freers))
	 (list "static void do_"
	       name "_free(struct lsh_object *o)\n"
	       "{\n"
	       "  struct " name " *i = (struct " name " *) o;\n"
	       (map (lambda (x) (list "  " x))
		    freers)
	       "}\n\n"))))

(define (do-class name super mark-function free-function meta methods)
  (define initializer
    (list "{ STATIC_HEADER,\n  "
	  (if super
	      ; FIXME: A cast (struct lsh_class *) or something
	      ; equivalent is needed if the super class is not a
	      ; struct lsh_class *. For now, fixed with macros
	      ; expanding to the right component of extended class
	      ; structures.
	      (list "&" super "_class")
	      "0")
	  ", sizeof(struct " name "),\n  "
	  (if mark-function (list "do_" name "_mark") "NULL") ",\n  "
	  (if free-function (list "do_" name "_free") "NULL") "\n"
	  "}"))
  (werror "do-class\n")
  (if meta
      (list "struct " meta "_meta " name "_class_extended =\n"
	    "{ " initializer 
	    (if methods
		(map (lambda (m) (list ",\n  " m)) methods)
		"")
	    "};\n"
	    "#define " name "_class (" name "_class_extended.super)\n")
      (list "struct lsh_class " name "_class =\n"
	    initializer ";\n")))

(define (process-class exp)
  (let ((type (car exp))
	(attributes (cdr exp)))
    (werror "process-class: type = ~S\n" type)
    (case type
      ((class)
       (let ((name (get 'name attributes cadr))
	     (super (get 'super attributes cadr))
	     (raw-vars (get 'vars attributes cdr))
	     (meta (get 'meta attributes cadr))
	     (methods (get 'methods attributes cdr)))
	 (werror "foo\n")
	 (let ((vars (map (lambda (var) (fix-method name var))
			  raw-vars)))
	   (let ((mark-function (do-mark-function name vars))
		 (free-function (do-free-function name vars)))
	     (werror "baar\n")
	     (list "#ifndef CLASS_DEFINE\n"	
		   (do-struct name super vars)
		   (if meta
		       (list "extern struct " meta "_meta "
			     name "_class_extended;\n")
		       (list "extern struct lsh_class " name "_class;\n"))
		   "#endif /* !CLASS_DEFINE */\n\n"
		   "#ifndef CLASS_DECLARE\n"
		   (or mark-function "")
		   (or free-function "")
		   (do-class name super mark-function free-function
			     meta methods)
		   "#endif /* !CLASS_DECLARE */\n\n")))))
      ((meta)
       (let ((name (get 'name attributes cadr))
	     (methods (get 'methods attributes cdr)))
	 (list "#ifndef CLASS_DEFINE\n"
	       "struct " name "_meta\n"
	       "{\n"
	       "  struct lsh_class super;\n"
	       (map (lambda (m) (list "  " m ";\n"))
		    methods)
	       "};\n"
	       "#endif /* !CLASS_DEFINE */\n\n")))
      (else (list "#error Unknown expression type " type "\n")))))



(define main
  (let ((test (lambda (s) (string-prefix? "/* CLASS:" s))))
    (lambda args
      (let ((exp (read-expression test)))
	(if (not (eof-object? exp))
	    (begin
	      (display (append-deep (process-class exp)))
	      (main)))))))

; (main)
